/**
* OpenDota API
* # Introduction The OpenDota API provides Dota 2 related data including advanced match data extracted from match replays.  **Beginning 2018-04-22, the OpenDota API is limited to 50,000 free calls per month and 60 requests/minute** We offer a Premium Tier with unlimited API calls and higher rate limits. Check out the [API page](https://www.opendota.com/api-keys) to learn more. 
*
* OpenAPI spec version: 17.6.1
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.apis

import io.swagger.client.models.Inline_response_200_1
import io.swagger.client.models.Inline_response_200_10
import io.swagger.client.models.Inline_response_200_11
import io.swagger.client.models.Inline_response_200_12
import io.swagger.client.models.Inline_response_200_2
import io.swagger.client.models.Inline_response_200_3
import io.swagger.client.models.Inline_response_200_4
import io.swagger.client.models.Inline_response_200_5
import io.swagger.client.models.Inline_response_200_6
import io.swagger.client.models.Inline_response_200_7
import io.swagger.client.models.Inline_response_200_8
import io.swagger.client.models.Inline_response_200_9

import io.swagger.client.infrastructure.*

class PlayersApi(basePath: kotlin.String = "https://api.opendota.com/api") : ApiClient(basePath) {

    /**
    * GET /players/{account_id}/counts
    * Counts in categories
    * @param accountId Steam32 account ID 
    * @param limit Number of matches to limit to (optional)
    * @param offset Number of matches to offset start by (optional)
    * @param win Whether the player won (optional)
    * @param patch Patch ID (optional)
    * @param gameMode Game Mode ID (optional)
    * @param lobbyType Lobby type ID (optional)
    * @param region Region ID (optional)
    * @param date Days previous (optional)
    * @param laneRole Lane Role ID (optional)
    * @param heroId Hero ID (optional)
    * @param isRadiant Whether the player was radiant (optional)
    * @param includedAccountId Account IDs in the match (array) (optional)
    * @param excludedAccountId Account IDs not in the match (array) (optional)
    * @param withHeroId Hero IDs on the player&#39;s team (array) (optional)
    * @param againstHeroId Hero IDs against the player&#39;s team (array) (optional)
    * @param significant Whether the match was significant for aggregation purposes (optional)
    * @param having The minimum number of games played, for filtering hero stats (optional)
    * @param sort The field to return matches sorted by in descending order (optional)
    * @return Inline_response_200_9
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdCountsGet(accountId: kotlin.Int, limit: kotlin.Int, offset: kotlin.Int, win: kotlin.Int, patch: kotlin.Int, gameMode: kotlin.Int, lobbyType: kotlin.Int, region: kotlin.Int, date: kotlin.Int, laneRole: kotlin.Int, heroId: kotlin.Int, isRadiant: kotlin.Int, includedAccountId: kotlin.Int, excludedAccountId: kotlin.Int, withHeroId: kotlin.Int, againstHeroId: kotlin.Int, significant: kotlin.Int, having: kotlin.Int, sort: kotlin.String) : Inline_response_200_9 {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "offset" to listOf("$offset"), "win" to listOf("$win"), "patch" to listOf("$patch"), "gameMode" to listOf("$gameMode"), "lobbyType" to listOf("$lobbyType"), "region" to listOf("$region"), "date" to listOf("$date"), "laneRole" to listOf("$laneRole"), "heroId" to listOf("$heroId"), "isRadiant" to listOf("$isRadiant"), "includedAccountId" to listOf("$includedAccountId"), "excludedAccountId" to listOf("$excludedAccountId"), "withHeroId" to listOf("$withHeroId"), "againstHeroId" to listOf("$againstHeroId"), "significant" to listOf("$significant"), "having" to listOf("$having"), "sort" to listOf("$sort"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/counts".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Inline_response_200_9>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Inline_response_200_9
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}
    * Player data
    * @param accountId Steam32 account ID 
    * @return Inline_response_200_1
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdGet(accountId: kotlin.Int) : Inline_response_200_1 {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Inline_response_200_1>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Inline_response_200_1
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/heroes
    * Heroes played
    * @param accountId Steam32 account ID 
    * @param limit Number of matches to limit to (optional)
    * @param offset Number of matches to offset start by (optional)
    * @param win Whether the player won (optional)
    * @param patch Patch ID (optional)
    * @param gameMode Game Mode ID (optional)
    * @param lobbyType Lobby type ID (optional)
    * @param region Region ID (optional)
    * @param date Days previous (optional)
    * @param laneRole Lane Role ID (optional)
    * @param heroId Hero ID (optional)
    * @param isRadiant Whether the player was radiant (optional)
    * @param includedAccountId Account IDs in the match (array) (optional)
    * @param excludedAccountId Account IDs not in the match (array) (optional)
    * @param withHeroId Hero IDs on the player&#39;s team (array) (optional)
    * @param againstHeroId Hero IDs against the player&#39;s team (array) (optional)
    * @param significant Whether the match was significant for aggregation purposes (optional)
    * @param having The minimum number of games played, for filtering hero stats (optional)
    * @param sort The field to return matches sorted by in descending order (optional)
    * @return kotlin.Array<Inline_response_200_5>
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdHeroesGet(accountId: kotlin.Int, limit: kotlin.Int, offset: kotlin.Int, win: kotlin.Int, patch: kotlin.Int, gameMode: kotlin.Int, lobbyType: kotlin.Int, region: kotlin.Int, date: kotlin.Int, laneRole: kotlin.Int, heroId: kotlin.Int, isRadiant: kotlin.Int, includedAccountId: kotlin.Int, excludedAccountId: kotlin.Int, withHeroId: kotlin.Int, againstHeroId: kotlin.Int, significant: kotlin.Int, having: kotlin.Int, sort: kotlin.String) : kotlin.Array<Inline_response_200_5> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "offset" to listOf("$offset"), "win" to listOf("$win"), "patch" to listOf("$patch"), "gameMode" to listOf("$gameMode"), "lobbyType" to listOf("$lobbyType"), "region" to listOf("$region"), "date" to listOf("$date"), "laneRole" to listOf("$laneRole"), "heroId" to listOf("$heroId"), "isRadiant" to listOf("$isRadiant"), "includedAccountId" to listOf("$includedAccountId"), "excludedAccountId" to listOf("$excludedAccountId"), "withHeroId" to listOf("$withHeroId"), "againstHeroId" to listOf("$againstHeroId"), "significant" to listOf("$significant"), "having" to listOf("$having"), "sort" to listOf("$sort"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/heroes".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Inline_response_200_5>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Inline_response_200_5>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/histograms
    * Distribution of matches in a single stat
    * @param accountId Steam32 account ID 
    * @param field Field to aggregate on 
    * @param limit Number of matches to limit to (optional)
    * @param offset Number of matches to offset start by (optional)
    * @param win Whether the player won (optional)
    * @param patch Patch ID (optional)
    * @param gameMode Game Mode ID (optional)
    * @param lobbyType Lobby type ID (optional)
    * @param region Region ID (optional)
    * @param date Days previous (optional)
    * @param laneRole Lane Role ID (optional)
    * @param heroId Hero ID (optional)
    * @param isRadiant Whether the player was radiant (optional)
    * @param includedAccountId Account IDs in the match (array) (optional)
    * @param excludedAccountId Account IDs not in the match (array) (optional)
    * @param withHeroId Hero IDs on the player&#39;s team (array) (optional)
    * @param againstHeroId Hero IDs against the player&#39;s team (array) (optional)
    * @param significant Whether the match was significant for aggregation purposes (optional)
    * @param having The minimum number of games played, for filtering hero stats (optional)
    * @param sort The field to return matches sorted by in descending order (optional)
    * @return kotlin.Array<kotlin.Any>
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdHistogramsFieldGet(accountId: kotlin.Int, field: kotlin.String, limit: kotlin.Int, offset: kotlin.Int, win: kotlin.Int, patch: kotlin.Int, gameMode: kotlin.Int, lobbyType: kotlin.Int, region: kotlin.Int, date: kotlin.Int, laneRole: kotlin.Int, heroId: kotlin.Int, isRadiant: kotlin.Int, includedAccountId: kotlin.Int, excludedAccountId: kotlin.Int, withHeroId: kotlin.Int, againstHeroId: kotlin.Int, significant: kotlin.Int, having: kotlin.Int, sort: kotlin.String) : kotlin.Array<kotlin.Any> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "offset" to listOf("$offset"), "win" to listOf("$win"), "patch" to listOf("$patch"), "gameMode" to listOf("$gameMode"), "lobbyType" to listOf("$lobbyType"), "region" to listOf("$region"), "date" to listOf("$date"), "laneRole" to listOf("$laneRole"), "heroId" to listOf("$heroId"), "isRadiant" to listOf("$isRadiant"), "includedAccountId" to listOf("$includedAccountId"), "excludedAccountId" to listOf("$excludedAccountId"), "withHeroId" to listOf("$withHeroId"), "againstHeroId" to listOf("$againstHeroId"), "significant" to listOf("$significant"), "having" to listOf("$having"), "sort" to listOf("$sort"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/histograms/{field}".replace("{"+"account_id"+"}", "$accountId").replace("{"+"field"+"}", "$field"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<kotlin.Any>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Any>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/matches
    * Matches played
    * @param accountId Steam32 account ID 
    * @param limit Number of matches to limit to (optional)
    * @param offset Number of matches to offset start by (optional)
    * @param win Whether the player won (optional)
    * @param patch Patch ID (optional)
    * @param gameMode Game Mode ID (optional)
    * @param lobbyType Lobby type ID (optional)
    * @param region Region ID (optional)
    * @param date Days previous (optional)
    * @param laneRole Lane Role ID (optional)
    * @param heroId Hero ID (optional)
    * @param isRadiant Whether the player was radiant (optional)
    * @param includedAccountId Account IDs in the match (array) (optional)
    * @param excludedAccountId Account IDs not in the match (array) (optional)
    * @param withHeroId Hero IDs on the player&#39;s team (array) (optional)
    * @param againstHeroId Hero IDs against the player&#39;s team (array) (optional)
    * @param significant Whether the match was significant for aggregation purposes (optional)
    * @param having The minimum number of games played, for filtering hero stats (optional)
    * @param sort The field to return matches sorted by in descending order (optional)
    * @param project Fields to project (array) (optional)
    * @return kotlin.Array<Inline_response_200_4>
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdMatchesGet(accountId: kotlin.Int, limit: kotlin.Int, offset: kotlin.Int, win: kotlin.Int, patch: kotlin.Int, gameMode: kotlin.Int, lobbyType: kotlin.Int, region: kotlin.Int, date: kotlin.Int, laneRole: kotlin.Int, heroId: kotlin.Int, isRadiant: kotlin.Int, includedAccountId: kotlin.Int, excludedAccountId: kotlin.Int, withHeroId: kotlin.Int, againstHeroId: kotlin.Int, significant: kotlin.Int, having: kotlin.Int, sort: kotlin.String, project: kotlin.String) : kotlin.Array<Inline_response_200_4> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "offset" to listOf("$offset"), "win" to listOf("$win"), "patch" to listOf("$patch"), "gameMode" to listOf("$gameMode"), "lobbyType" to listOf("$lobbyType"), "region" to listOf("$region"), "date" to listOf("$date"), "laneRole" to listOf("$laneRole"), "heroId" to listOf("$heroId"), "isRadiant" to listOf("$isRadiant"), "includedAccountId" to listOf("$includedAccountId"), "excludedAccountId" to listOf("$excludedAccountId"), "withHeroId" to listOf("$withHeroId"), "againstHeroId" to listOf("$againstHeroId"), "significant" to listOf("$significant"), "having" to listOf("$having"), "sort" to listOf("$sort"), "project" to listOf("$project"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/matches".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Inline_response_200_4>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Inline_response_200_4>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/peers
    * Players played with
    * @param accountId Steam32 account ID 
    * @param limit Number of matches to limit to (optional)
    * @param offset Number of matches to offset start by (optional)
    * @param win Whether the player won (optional)
    * @param patch Patch ID (optional)
    * @param gameMode Game Mode ID (optional)
    * @param lobbyType Lobby type ID (optional)
    * @param region Region ID (optional)
    * @param date Days previous (optional)
    * @param laneRole Lane Role ID (optional)
    * @param heroId Hero ID (optional)
    * @param isRadiant Whether the player was radiant (optional)
    * @param includedAccountId Account IDs in the match (array) (optional)
    * @param excludedAccountId Account IDs not in the match (array) (optional)
    * @param withHeroId Hero IDs on the player&#39;s team (array) (optional)
    * @param againstHeroId Hero IDs against the player&#39;s team (array) (optional)
    * @param significant Whether the match was significant for aggregation purposes (optional)
    * @param having The minimum number of games played, for filtering hero stats (optional)
    * @param sort The field to return matches sorted by in descending order (optional)
    * @return kotlin.Array<Inline_response_200_6>
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdPeersGet(accountId: kotlin.Int, limit: kotlin.Int, offset: kotlin.Int, win: kotlin.Int, patch: kotlin.Int, gameMode: kotlin.Int, lobbyType: kotlin.Int, region: kotlin.Int, date: kotlin.Int, laneRole: kotlin.Int, heroId: kotlin.Int, isRadiant: kotlin.Int, includedAccountId: kotlin.Int, excludedAccountId: kotlin.Int, withHeroId: kotlin.Int, againstHeroId: kotlin.Int, significant: kotlin.Int, having: kotlin.Int, sort: kotlin.String) : kotlin.Array<Inline_response_200_6> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "offset" to listOf("$offset"), "win" to listOf("$win"), "patch" to listOf("$patch"), "gameMode" to listOf("$gameMode"), "lobbyType" to listOf("$lobbyType"), "region" to listOf("$region"), "date" to listOf("$date"), "laneRole" to listOf("$laneRole"), "heroId" to listOf("$heroId"), "isRadiant" to listOf("$isRadiant"), "includedAccountId" to listOf("$includedAccountId"), "excludedAccountId" to listOf("$excludedAccountId"), "withHeroId" to listOf("$withHeroId"), "againstHeroId" to listOf("$againstHeroId"), "significant" to listOf("$significant"), "having" to listOf("$having"), "sort" to listOf("$sort"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/peers".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Inline_response_200_6>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Inline_response_200_6>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/pros
    * Pro players played with
    * @param accountId Steam32 account ID 
    * @param limit Number of matches to limit to (optional)
    * @param offset Number of matches to offset start by (optional)
    * @param win Whether the player won (optional)
    * @param patch Patch ID (optional)
    * @param gameMode Game Mode ID (optional)
    * @param lobbyType Lobby type ID (optional)
    * @param region Region ID (optional)
    * @param date Days previous (optional)
    * @param laneRole Lane Role ID (optional)
    * @param heroId Hero ID (optional)
    * @param isRadiant Whether the player was radiant (optional)
    * @param includedAccountId Account IDs in the match (array) (optional)
    * @param excludedAccountId Account IDs not in the match (array) (optional)
    * @param withHeroId Hero IDs on the player&#39;s team (array) (optional)
    * @param againstHeroId Hero IDs against the player&#39;s team (array) (optional)
    * @param significant Whether the match was significant for aggregation purposes (optional)
    * @param having The minimum number of games played, for filtering hero stats (optional)
    * @param sort The field to return matches sorted by in descending order (optional)
    * @return kotlin.Array<Inline_response_200_7>
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdProsGet(accountId: kotlin.Int, limit: kotlin.Int, offset: kotlin.Int, win: kotlin.Int, patch: kotlin.Int, gameMode: kotlin.Int, lobbyType: kotlin.Int, region: kotlin.Int, date: kotlin.Int, laneRole: kotlin.Int, heroId: kotlin.Int, isRadiant: kotlin.Int, includedAccountId: kotlin.Int, excludedAccountId: kotlin.Int, withHeroId: kotlin.Int, againstHeroId: kotlin.Int, significant: kotlin.Int, having: kotlin.Int, sort: kotlin.String) : kotlin.Array<Inline_response_200_7> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "offset" to listOf("$offset"), "win" to listOf("$win"), "patch" to listOf("$patch"), "gameMode" to listOf("$gameMode"), "lobbyType" to listOf("$lobbyType"), "region" to listOf("$region"), "date" to listOf("$date"), "laneRole" to listOf("$laneRole"), "heroId" to listOf("$heroId"), "isRadiant" to listOf("$isRadiant"), "includedAccountId" to listOf("$includedAccountId"), "excludedAccountId" to listOf("$excludedAccountId"), "withHeroId" to listOf("$withHeroId"), "againstHeroId" to listOf("$againstHeroId"), "significant" to listOf("$significant"), "having" to listOf("$having"), "sort" to listOf("$sort"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/pros".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Inline_response_200_7>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Inline_response_200_7>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/rankings
    * Player hero rankings
    * @param accountId Steam32 account ID 
    * @return kotlin.Array<kotlin.Any>
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdRankingsGet(accountId: kotlin.Int) : kotlin.Array<kotlin.Any> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/rankings".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<kotlin.Any>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Any>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/ratings
    * Player rating history
    * @param accountId Steam32 account ID 
    * @return kotlin.Array<Inline_response_200_12>
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdRatingsGet(accountId: kotlin.Int) : kotlin.Array<Inline_response_200_12> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/ratings".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Inline_response_200_12>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Inline_response_200_12>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/recentMatches
    * Recent matches played
    * @param accountId Steam32 account ID 
    * @return kotlin.Array<Inline_response_200_3>
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdRecentMatchesGet(accountId: kotlin.Int) : kotlin.Array<Inline_response_200_3> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/recentMatches".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Inline_response_200_3>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Inline_response_200_3>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * POST /players/{account_id}/refresh
    * Refresh player match history
    * @param accountId Steam32 account ID 
    * @return kotlin.Any
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdRefreshPost(accountId: kotlin.Int) : kotlin.Any {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/players/{account_id}/refresh".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Any>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Any
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/totals
    * Totals in stats
    * @param accountId Steam32 account ID 
    * @param limit Number of matches to limit to (optional)
    * @param offset Number of matches to offset start by (optional)
    * @param win Whether the player won (optional)
    * @param patch Patch ID (optional)
    * @param gameMode Game Mode ID (optional)
    * @param lobbyType Lobby type ID (optional)
    * @param region Region ID (optional)
    * @param date Days previous (optional)
    * @param laneRole Lane Role ID (optional)
    * @param heroId Hero ID (optional)
    * @param isRadiant Whether the player was radiant (optional)
    * @param includedAccountId Account IDs in the match (array) (optional)
    * @param excludedAccountId Account IDs not in the match (array) (optional)
    * @param withHeroId Hero IDs on the player&#39;s team (array) (optional)
    * @param againstHeroId Hero IDs against the player&#39;s team (array) (optional)
    * @param significant Whether the match was significant for aggregation purposes (optional)
    * @param having The minimum number of games played, for filtering hero stats (optional)
    * @param sort The field to return matches sorted by in descending order (optional)
    * @return kotlin.Array<Inline_response_200_8>
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdTotalsGet(accountId: kotlin.Int, limit: kotlin.Int, offset: kotlin.Int, win: kotlin.Int, patch: kotlin.Int, gameMode: kotlin.Int, lobbyType: kotlin.Int, region: kotlin.Int, date: kotlin.Int, laneRole: kotlin.Int, heroId: kotlin.Int, isRadiant: kotlin.Int, includedAccountId: kotlin.Int, excludedAccountId: kotlin.Int, withHeroId: kotlin.Int, againstHeroId: kotlin.Int, significant: kotlin.Int, having: kotlin.Int, sort: kotlin.String) : kotlin.Array<Inline_response_200_8> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "offset" to listOf("$offset"), "win" to listOf("$win"), "patch" to listOf("$patch"), "gameMode" to listOf("$gameMode"), "lobbyType" to listOf("$lobbyType"), "region" to listOf("$region"), "date" to listOf("$date"), "laneRole" to listOf("$laneRole"), "heroId" to listOf("$heroId"), "isRadiant" to listOf("$isRadiant"), "includedAccountId" to listOf("$includedAccountId"), "excludedAccountId" to listOf("$excludedAccountId"), "withHeroId" to listOf("$withHeroId"), "againstHeroId" to listOf("$againstHeroId"), "significant" to listOf("$significant"), "having" to listOf("$having"), "sort" to listOf("$sort"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/totals".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Inline_response_200_8>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Inline_response_200_8>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/wardmap
    * Wards placed in matches played
    * @param accountId Steam32 account ID 
    * @param limit Number of matches to limit to (optional)
    * @param offset Number of matches to offset start by (optional)
    * @param win Whether the player won (optional)
    * @param patch Patch ID (optional)
    * @param gameMode Game Mode ID (optional)
    * @param lobbyType Lobby type ID (optional)
    * @param region Region ID (optional)
    * @param date Days previous (optional)
    * @param laneRole Lane Role ID (optional)
    * @param heroId Hero ID (optional)
    * @param isRadiant Whether the player was radiant (optional)
    * @param includedAccountId Account IDs in the match (array) (optional)
    * @param excludedAccountId Account IDs not in the match (array) (optional)
    * @param withHeroId Hero IDs on the player&#39;s team (array) (optional)
    * @param againstHeroId Hero IDs against the player&#39;s team (array) (optional)
    * @param significant Whether the match was significant for aggregation purposes (optional)
    * @param having The minimum number of games played, for filtering hero stats (optional)
    * @param sort The field to return matches sorted by in descending order (optional)
    * @return Inline_response_200_10
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdWardmapGet(accountId: kotlin.Int, limit: kotlin.Int, offset: kotlin.Int, win: kotlin.Int, patch: kotlin.Int, gameMode: kotlin.Int, lobbyType: kotlin.Int, region: kotlin.Int, date: kotlin.Int, laneRole: kotlin.Int, heroId: kotlin.Int, isRadiant: kotlin.Int, includedAccountId: kotlin.Int, excludedAccountId: kotlin.Int, withHeroId: kotlin.Int, againstHeroId: kotlin.Int, significant: kotlin.Int, having: kotlin.Int, sort: kotlin.String) : Inline_response_200_10 {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "offset" to listOf("$offset"), "win" to listOf("$win"), "patch" to listOf("$patch"), "gameMode" to listOf("$gameMode"), "lobbyType" to listOf("$lobbyType"), "region" to listOf("$region"), "date" to listOf("$date"), "laneRole" to listOf("$laneRole"), "heroId" to listOf("$heroId"), "isRadiant" to listOf("$isRadiant"), "includedAccountId" to listOf("$includedAccountId"), "excludedAccountId" to listOf("$excludedAccountId"), "withHeroId" to listOf("$withHeroId"), "againstHeroId" to listOf("$againstHeroId"), "significant" to listOf("$significant"), "having" to listOf("$having"), "sort" to listOf("$sort"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/wardmap".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Inline_response_200_10>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Inline_response_200_10
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/wl
    * Win/Loss count
    * @param accountId Steam32 account ID 
    * @param limit Number of matches to limit to (optional)
    * @param offset Number of matches to offset start by (optional)
    * @param win Whether the player won (optional)
    * @param patch Patch ID (optional)
    * @param gameMode Game Mode ID (optional)
    * @param lobbyType Lobby type ID (optional)
    * @param region Region ID (optional)
    * @param date Days previous (optional)
    * @param laneRole Lane Role ID (optional)
    * @param heroId Hero ID (optional)
    * @param isRadiant Whether the player was radiant (optional)
    * @param includedAccountId Account IDs in the match (array) (optional)
    * @param excludedAccountId Account IDs not in the match (array) (optional)
    * @param withHeroId Hero IDs on the player&#39;s team (array) (optional)
    * @param againstHeroId Hero IDs against the player&#39;s team (array) (optional)
    * @param significant Whether the match was significant for aggregation purposes (optional)
    * @param having The minimum number of games played, for filtering hero stats (optional)
    * @param sort The field to return matches sorted by in descending order (optional)
    * @return Inline_response_200_2
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdWlGet(accountId: kotlin.Int, limit: kotlin.Int, offset: kotlin.Int, win: kotlin.Int, patch: kotlin.Int, gameMode: kotlin.Int, lobbyType: kotlin.Int, region: kotlin.Int, date: kotlin.Int, laneRole: kotlin.Int, heroId: kotlin.Int, isRadiant: kotlin.Int, includedAccountId: kotlin.Int, excludedAccountId: kotlin.Int, withHeroId: kotlin.Int, againstHeroId: kotlin.Int, significant: kotlin.Int, having: kotlin.Int, sort: kotlin.String) : Inline_response_200_2 {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "offset" to listOf("$offset"), "win" to listOf("$win"), "patch" to listOf("$patch"), "gameMode" to listOf("$gameMode"), "lobbyType" to listOf("$lobbyType"), "region" to listOf("$region"), "date" to listOf("$date"), "laneRole" to listOf("$laneRole"), "heroId" to listOf("$heroId"), "isRadiant" to listOf("$isRadiant"), "includedAccountId" to listOf("$includedAccountId"), "excludedAccountId" to listOf("$excludedAccountId"), "withHeroId" to listOf("$withHeroId"), "againstHeroId" to listOf("$againstHeroId"), "significant" to listOf("$significant"), "having" to listOf("$having"), "sort" to listOf("$sort"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/wl".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Inline_response_200_2>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Inline_response_200_2
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * GET /players/{account_id}/wordcloud
    * Words said/read in matches played
    * @param accountId Steam32 account ID 
    * @param limit Number of matches to limit to (optional)
    * @param offset Number of matches to offset start by (optional)
    * @param win Whether the player won (optional)
    * @param patch Patch ID (optional)
    * @param gameMode Game Mode ID (optional)
    * @param lobbyType Lobby type ID (optional)
    * @param region Region ID (optional)
    * @param date Days previous (optional)
    * @param laneRole Lane Role ID (optional)
    * @param heroId Hero ID (optional)
    * @param isRadiant Whether the player was radiant (optional)
    * @param includedAccountId Account IDs in the match (array) (optional)
    * @param excludedAccountId Account IDs not in the match (array) (optional)
    * @param withHeroId Hero IDs on the player&#39;s team (array) (optional)
    * @param againstHeroId Hero IDs against the player&#39;s team (array) (optional)
    * @param significant Whether the match was significant for aggregation purposes (optional)
    * @param having The minimum number of games played, for filtering hero stats (optional)
    * @param sort The field to return matches sorted by in descending order (optional)
    * @return Inline_response_200_11
    */
    @Suppress("UNCHECKED_CAST")
    fun playersAccountIdWordcloudGet(accountId: kotlin.Int, limit: kotlin.Int, offset: kotlin.Int, win: kotlin.Int, patch: kotlin.Int, gameMode: kotlin.Int, lobbyType: kotlin.Int, region: kotlin.Int, date: kotlin.Int, laneRole: kotlin.Int, heroId: kotlin.Int, isRadiant: kotlin.Int, includedAccountId: kotlin.Int, excludedAccountId: kotlin.Int, withHeroId: kotlin.Int, againstHeroId: kotlin.Int, significant: kotlin.Int, having: kotlin.Int, sort: kotlin.String) : Inline_response_200_11 {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "offset" to listOf("$offset"), "win" to listOf("$win"), "patch" to listOf("$patch"), "gameMode" to listOf("$gameMode"), "lobbyType" to listOf("$lobbyType"), "region" to listOf("$region"), "date" to listOf("$date"), "laneRole" to listOf("$laneRole"), "heroId" to listOf("$heroId"), "isRadiant" to listOf("$isRadiant"), "includedAccountId" to listOf("$includedAccountId"), "excludedAccountId" to listOf("$excludedAccountId"), "withHeroId" to listOf("$withHeroId"), "againstHeroId" to listOf("$againstHeroId"), "significant" to listOf("$significant"), "having" to listOf("$having"), "sort" to listOf("$sort"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/players/{account_id}/wordcloud".replace("{"+"account_id"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Inline_response_200_11>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Inline_response_200_11
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
