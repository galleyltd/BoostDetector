/**
* OpenDota API
* # Introduction The OpenDota API provides Dota 2 related data including advanced match data extracted from match replays.  **Beginning 2018-04-22, the OpenDota API is limited to 50,000 free calls per month and 60 requests/minute** We offer a Premium Tier with unlimited API calls and higher rate limits. Check out the [API page](https://www.opendota.com/api-keys) to learn more. 
*
* OpenAPI spec version: 17.6.1
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.models

import io.swagger.client.models.Inline_response_200_chat
import io.swagger.client.models.Inline_response_200_draft_timings
import io.swagger.client.models.Inline_response_200_players

/**
 * 
 * @param match_id The ID number of the match assigned by Valve
 * @param barracks_status_dire Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game.
 * @param barracks_status_radiant Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game.
 * @param chat Array containing information on the chat of the game
 * @param cluster cluster
 * @param cosmetics cosmetics
 * @param dire_score Final score for Dire (number of kills on Radiant)
 * @param draft_timings draft_timings
 * @param duration Duration of the game in seconds
 * @param engine engine
 * @param first_blood_time Time in seconds at which first blood occurred
 * @param game_mode Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
 * @param human_players Number of human players in the game
 * @param leagueid leagueid
 * @param lobby_type Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
 * @param match_seq_num match_seq_num
 * @param negative_votes Number of negative votes the replay received in the in-game client
 * @param objectives objectives
 * @param picks_bans Object containing information on the draft. Each pick/ban contains a boolean relating to whether the choice is a pick or a ban, the hero ID, the team the picked or banned it, and the order.
 * @param positive_votes Number of positive votes the replay received in the in-game client
 * @param radiant_gold_adv Array of the Radiant gold advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their gold disadvantage. 
 * @param radiant_score Final score for Radiant (number of kills on Radiant)
 * @param radiant_win Boolean indicating whether Radiant won the match
 * @param radiant_xp_adv Array of the Radiant experience advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their experience disadvantage. 
 * @param start_time The Unix timestamp at which the game started
 * @param teamfights teamfights
 * @param tower_status_dire Bitmask. An integer that represents a binary of which Dire towers are still standing.
 * @param tower_status_radiant Bitmask. An integer that represents a binary of which Radiant towers are still standing.
 * @param version Parse version, used internally by OpenDota
 * @param replay_salt replay_salt
 * @param series_id series_id
 * @param series_type series_type
 * @param radiant_team radiant_team
 * @param dire_team dire_team
 * @param league league
 * @param skill Skill bracket assigned by Valve (Normal, High, Very High)
 * @param players Array of information on individual players
 * @param patch Information on the patch version the game is played on
 * @param region Integer corresponding to the region the game was played on
 * @param all_word_counts Word counts of the all chat messages in the player's games
 * @param my_word_counts Word counts of the player's all chat messages
 * @param &#x60;throw&#x60; Maximum gold advantage of the player's team if they lost the match
 * @param comeback Maximum gold disadvantage of the player's team if they won the match
 * @param loss Maximum gold disadvantage of the player's team if they lost the match
 * @param win Maximum gold advantage of the player's team if they won the match
 * @param replay_url replay_url
 */
data class Inline_response_200 (
    /* The ID number of the match assigned by Valve */
    val match_id: kotlin.String? = null,
    /* Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game. */
    val barracks_status_dire: kotlin.Int? = null,
    /* Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game. */
    val barracks_status_radiant: kotlin.Int? = null,
    /* Array containing information on the chat of the game */
    val chat: kotlin.Array<Inline_response_200_chat>? = null,
    /* cluster */
    val cluster: kotlin.Int? = null,
    /* cosmetics */
    val cosmetics: kotlin.Any? = null,
    /* Final score for Dire (number of kills on Radiant) */
    val dire_score: kotlin.Int? = null,
    /* draft_timings */
    val draft_timings: kotlin.Array<Inline_response_200_draft_timings>? = null,
    /* Duration of the game in seconds */
    val duration: kotlin.Int? = null,
    /* engine */
    val engine: kotlin.Int? = null,
    /* Time in seconds at which first blood occurred */
    val first_blood_time: kotlin.Int? = null,
    /* Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json */
    val game_mode: kotlin.Int? = null,
    /* Number of human players in the game */
    val human_players: kotlin.Int? = null,
    /* leagueid */
    val leagueid: kotlin.Int? = null,
    /* Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json */
    val lobby_type: kotlin.Int? = null,
    /* match_seq_num */
    val match_seq_num: kotlin.String? = null,
    /* Number of negative votes the replay received in the in-game client */
    val negative_votes: kotlin.Int? = null,
    /* objectives */
    val objectives: kotlin.Any? = null,
    /* Object containing information on the draft. Each pick/ban contains a boolean relating to whether the choice is a pick or a ban, the hero ID, the team the picked or banned it, and the order. */
    val picks_bans: kotlin.Any? = null,
    /* Number of positive votes the replay received in the in-game client */
    val positive_votes: kotlin.Int? = null,
    /* Array of the Radiant gold advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their gold disadvantage.  */
    val radiant_gold_adv: kotlin.Any? = null,
    /* Final score for Radiant (number of kills on Radiant) */
    val radiant_score: kotlin.Int? = null,
    /* Boolean indicating whether Radiant won the match */
    val radiant_win: kotlin.Boolean? = null,
    /* Array of the Radiant experience advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their experience disadvantage.  */
    val radiant_xp_adv: kotlin.Any? = null,
    /* The Unix timestamp at which the game started */
    val start_time: kotlin.Int? = null,
    /* teamfights */
    val teamfights: kotlin.Any? = null,
    /* Bitmask. An integer that represents a binary of which Dire towers are still standing. */
    val tower_status_dire: kotlin.Int? = null,
    /* Bitmask. An integer that represents a binary of which Radiant towers are still standing. */
    val tower_status_radiant: kotlin.Int? = null,
    /* Parse version, used internally by OpenDota */
    val version: kotlin.Int? = null,
    /* replay_salt */
    val replay_salt: kotlin.Int? = null,
    /* series_id */
    val series_id: kotlin.Int? = null,
    /* series_type */
    val series_type: kotlin.Int? = null,
    /* radiant_team */
    val radiant_team: kotlin.Any? = null,
    /* dire_team */
    val dire_team: kotlin.Any? = null,
    /* league */
    val league: kotlin.Any? = null,
    /* Skill bracket assigned by Valve (Normal, High, Very High) */
    val skill: kotlin.Int? = null,
    /* Array of information on individual players */
    val players: kotlin.Array<Inline_response_200_players>? = null,
    /* Information on the patch version the game is played on */
    val patch: kotlin.Int? = null,
    /* Integer corresponding to the region the game was played on */
    val region: kotlin.Int? = null,
    /* Word counts of the all chat messages in the player's games */
    val all_word_counts: kotlin.Any? = null,
    /* Word counts of the player's all chat messages */
    val my_word_counts: kotlin.Any? = null,
    /* Maximum gold advantage of the player's team if they lost the match */
    val `throw`: kotlin.Int? = null,
    /* Maximum gold disadvantage of the player's team if they won the match */
    val comeback: kotlin.Int? = null,
    /* Maximum gold disadvantage of the player's team if they lost the match */
    val loss: kotlin.Int? = null,
    /* Maximum gold advantage of the player's team if they won the match */
    val win: kotlin.Int? = null,
    /* replay_url */
    val replay_url: kotlin.String? = null
) {

}

